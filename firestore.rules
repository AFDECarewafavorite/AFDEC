/**
 * Core Philosophy: This ruleset enforces a strict, role-based security model for a chicken booking application.
 * The primary roles are Customer, Agent, Manager, and CEO. Access is primarily dictated by data ownership, where users
 * can only access data nested under their own unique ID. Higher-level roles (Manager, CEO) are granted broader read
 * and management permissions across the system. The CEO has ultimate authority, including the ability to manage user roles.
 *
 * Data Structure: The data is hierarchically organized to enforce ownership naturally through Firestore paths.
 * - /users/{userId}/...: All data private to a specific user (profile, bookings).
 * - /agents/{agentId}/...: All data private to a specific agent (profile, commissions, withdrawals).
 * - /roles_ceo/{userId}: A lookup collection to grant system-wide CEO privileges.
 * - /roles_manager/{userId}: A lookup collection to grant system-wide Manager privileges.
 * - /products/{productId}: A global collection of available products.
 *
 * Key Security Decisions:
 * - Default Deny: All operations are denied by default and must be explicitly allowed.
 * - Path-Based Ownership: A user's UID in the document path is the primary mechanism for granting access.
 * - Role Segregation: CEO and Manager privileges are managed in separate collections (`/roles_ceo`, `/roles_manager`).
 *   This is a classic denormalization pattern for efficient role lookups and prevents self-escalation of privileges.
 * - System-Generated Data: Collections like `/commissions` are read-only for agents, assuming they are created by a trusted backend.
 * - Immutable Ownership: Critical relational fields are enforced to be immutable after creation.
 * - Suspension Check: The rules do not yet enforce account suspension. An `isSuspended` flag can be added to user profiles,
 *   but enforcement requires careful implementation (e.g., via custom claims or widespread `get()` calls) to avoid performance issues.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------
    function isSignedIn() {
      return request.auth != null;
    }

    function isCEO() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_ceo/$(request.auth.uid));
    }

    function isManager() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_manager/$(request.auth.uid));
    }
    
    function isPrivileged() {
        return isCEO() || isManager();
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAgent() {
      return isSignedIn() && exists(/databases/$(database)/documents/agents/$(request.auth.uid));
    }

    function isExistingDoc() {
      return resource != null;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    match /roles_ceo/{userId} {
      allow get: if isOwner(userId) || isCEO();
      allow list: if isCEO();
      allow write: if isCEO(); // CEOs can manage other CEOs
      allow delete: if isCEO();
    }

    match /roles_manager/{userId} {
      allow get: if isOwner(userId) || isCEO();
      allow list: if isCEO();
      allow write: if isCEO(); // Only CEOs can make or remove managers
      allow delete: if isCEO();
    }

    match /products/{productId} {
      allow read: if true;
      allow write: if isPrivileged();
    }

    match /users/{userId} {
      allow get: if isOwner(userId) || isCEO();
      allow list: if isCEO();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      // Allow user to update their own doc, and CEO to update any user doc (for role changes/suspension)
      allow update: if (isExistingOwner(userId) && request.resource.data.id == resource.data.id) || (isCEO() && isExistingDoc());
      allow delete: if isExistingOwner(userId) || isCEO();
    }

    match /users/{userId}/bookings/{bookingId} {
      allow get: if isOwner(userId) || isPrivileged() || (isAgent() && resource.data.agentId == request.auth.uid);
      allow list: if isOwner(userId) || isPrivileged();
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) || (isPrivileged() && isExistingDoc());
      allow delete: if isExistingOwner(userId);
    }
    
    match /{path=**}/bookings/{bookingId} {
      allow get, list: if isPrivileged() || (isAgent() && resource.data.agentId == request.auth.uid);
    }

    match /agents/{agentId} {
      allow get: if isOwner(agentId) || isPrivileged();
      allow list: if isPrivileged();
      allow create: if isOwner(agentId) && request.resource.data.userId == agentId;
      // Allow agent to update their own profile, or privileged users to manage them.
      allow update: if isExistingOwner(agentId) || isPrivileged();
      allow delete: if isExistingOwner(agentId) || isPrivileged();
    }

    match /agents/{agentId}/commissions/{commissionId} {
      allow get: if isOwner(agentId) || isPrivileged();
      allow list: if isOwner(agentId) || isPrivileged();
      allow create: if false; // Server-side logic
      allow update: if false; // Server-side logic
      allow delete: if false; // Server-side logic
    }

    match /agents/{agentId}/withdrawals/{withdrawalId} {
      allow get: if isOwner(agentId) || isPrivileged();
      allow list: if isOwner(agentId) || isPrivileged();
      allow create: if isOwner(agentId) && request.resource.data.agentId == agentId;
      allow update: if isPrivileged() && isExistingDoc();
      allow delete: if false;
    }
  }
}
