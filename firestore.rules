/**
 * Core Philosophy: This ruleset enforces a strict, role-based security model for a chicken booking application.
 * The primary roles are Customer, Agent, Manager, and CEO. Access is primarily dictated by data ownership, where users
 * can only access data nested under their own unique ID. Higher-level roles (Manager, CEO) are granted broader read
 * and management permissions across the system. The CEO has ultimate authority, including the ability to manage user roles.
 *
 * Data Structure: The data is hierarchically organized to enforce ownership naturally through Firestore paths.
 * - /users/{userId}/...: All data private to a specific user (profile, bookings).
 * - /agents/{agentId}/...: All data private to a specific agent (profile, commissions, withdrawals).
 * - /roles_ceo/{userId}: A lookup collection to grant system-wide CEO privileges.
 * - /roles_manager/{userId}: A lookup collection to grant system-wide Manager privileges.
 * - /products/{productId}: A global collection of available products.
 *
 * Key Security Decisions:
 * - Default Deny: All operations are denied by default and must be explicitly allowed.
 * - Path-Based Ownership: A user's UID in the document path is the primary mechanism for granting access.
 * - Role Segregation: CEO and Manager privileges are managed in separate collections (`/roles_ceo`, `/roles_manager`).
 *   This is a classic denormalization pattern for efficient role lookups and prevents self-escalation of privileges.
 * - CEO Supremacy: The CEO role has broad, system-wide read and write access.
 * - Manager Focus: The Manager role is limited to managing bookings and products, but cannot manage users or agents.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------
    function isSignedIn() {
      return request.auth != null;
    }

    function isCEO() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_ceo/$(request.auth.uid));
    }

    function isManager() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_manager/$(request.auth.uid));
    }
    
    function isPrivileged() {
        return isManager() || isCEO();
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAgent() {
      return isSignedIn() && exists(/databases/$(database)/documents/agents/$(request.auth.uid));
    }

    function isExistingDoc() {
      return resource != null;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    // A user can check their own role document to verify permissions.
    // Only the CEO can list all roles or modify them.
    match /roles_ceo/{userId} {
      allow get: if isOwner(userId) || isCEO();
      allow list, write, delete: if isCEO();
    }

    match /roles_manager/{userId} {
      allow get: if isOwner(userId) || isCEO();
      allow list, write, delete: if isCEO();
    }

    // Products can be read by anyone, but only managed by privileged users (Manager, CEO).
    match /products/{productId} {
      allow read: if true;
      allow write: if isPrivileged();
    }

    // Users can be created by anyone (signup).
    // A user can get their own profile.
    // The CEO can list, get, update (e.g. for role change/suspension), and delete any user.
    match /users/{userId} {
      allow get: if isOwner(userId) || isCEO();
      allow list: if isCEO();
      allow create: if true; 
      allow update: if isOwner(userId) || isCEO();
      allow delete: if isOwner(userId) || isCEO();
    }

    // - A user can manage their own bookings.
    // - Privileged users (Manager, CEO) can view any booking.
    // - An agent can view a booking they are referred in.
    match /users/{userId}/bookings/{bookingId} {
      allow get: if isOwner(userId) || isPrivileged() || (isAgent() && resource.data.agentId == request.auth.uid);
      allow list: if isOwner(userId) || isPrivileged();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) || isPrivileged();
      allow delete: if isOwner(userId);
    }
    
    // This allows Managers/CEOs to use a collectionGroup query across all bookings.
    match /{path=**}/bookings/{bookingId} {
      allow read: if isPrivileged();
    }

    // Agents can get their own profile.
    // The CEO can create, list, get, update, and delete any agent profile.
    match /agents/{agentId} {
      allow get: if isOwner(agentId) || isCEO();
      allow list: if isCEO();
      allow create: if isCEO();
      allow update: if isOwner(agentId) || isCEO();
      allow delete: if isOwner(agentId) || isCEO();
    }

    // Commissions can be created by privileged users (Manager marking a booking complete).
    // An agent can read their own commissions.
    // The CEO can read anyone's commissions for auditing.
    match /agents/{agentId}/commissions/{commissionId} {
      allow get: if isOwner(agentId) || isCEO();
      allow list: if isOwner(agentId) || isCEO();
      allow create: if isPrivileged();
      allow update: if false; // Server-side logic only
      allow delete: if false; // Server-side logic only
    }

    // An agent can create their own withdrawal requests.
    // Privileged users (Manager, CEO) can view and update (approve/reject) withdrawals.
    match /agents/{agentId}/withdrawals/{withdrawalId} {
      allow get: if isOwner(agentId) || isPrivileged();
      allow list: if isOwner(agentId) || isPrivileged();
      allow create: if isOwner(agentId) && request.resource.data.agentId == agentId;
      allow update: if isPrivileged() && isExistingDoc();
      allow delete: if false; // Disallow deletion for record-keeping
    }
  }
}
